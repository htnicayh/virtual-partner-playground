<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Virtual Partner Playground</title>
		<link rel="icon" href="favicon.png" />
		<script src="https://cdn.socket.io/4.8.2/socket.io.min.js"></script>
		<style>
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
			}

			body {
				font-family:
					-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Fira Sans', 'Droid Sans',
					'Helvetica Neue', sans-serif;
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				min-height: 100vh;
				display: flex;
				padding: 20px;
				gap: 20px;
			}

			.main-content {
				display: flex;
				gap: 20px;
				width: 100%;
				max-width: 1200px;
				margin: 0 auto;
			}

			.container {
				background: white;
				border-radius: 12px;
				box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
				max-width: 600px;
				width: 100%;
				padding: 40px;
				flex: 1;
			}

			.chat-sidebar {
				background: white;
				border-radius: 12px;
				box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
				width: 350px;
				padding: 20px;
				display: flex;
				flex-direction: column;
				gap: 15px;
			}

			.sidebar-title {
				font-size: 16px;
				font-weight: 700;
				color: #333;
				margin-bottom: 0;
				border-bottom: 2px solid #667eea;
				padding-bottom: 10px;
			}

			.sidebar-messages {
				flex: 1;
				overflow-y: auto;
				overflow-x: hidden;
				display: flex;
				flex-direction: column;
				gap: 10px;
				max-height: calc(100vh - 200px);
				min-height: 300px;
			}

			.sidebar-messages::-webkit-scrollbar {
				width: 6px;
			}

			.sidebar-messages::-webkit-scrollbar-track {
				background: #f1f1f1;
				border-radius: 3px;
			}

			.sidebar-messages::-webkit-scrollbar-thumb {
				background: #888;
				border-radius: 3px;
			}

			.sidebar-messages::-webkit-scrollbar-thumb:hover {
				background: #555;
			}

			.sidebar-message {
				padding: 10px 12px;
				border-radius: 6px;
				font-size: 12px;
				line-height: 1.4;
			}

			.sidebar-message.user {
				background: #e3f2fd;
				border-left: 3px solid #667eea;
				text-align: right;
			}

			.sidebar-message.assistant {
				background: #f1f8e9;
				border-left: 3px solid #4caf50;
			}

			.sidebar-message.loading {
				background: #f1f8e9;
				border-left: 3px solid #4caf50;
				text-align: left;
				padding: 15px 12px;
			}

			.loading-dots {
				display: inline-flex;
				align-items: center;
				gap: 3px;
			}

			.loading-dots span {
				display: inline-block;
				width: 6px;
				height: 6px;
				background-color: #4caf50;
				border-radius: 50%;
				animation: loading-bounce 1.4s infinite ease-in-out both;
			}

			.loading-dots span:nth-child(1) {
				animation-delay: -0.32s;
			}

			.loading-dots span:nth-child(2) {
				animation-delay: -0.16s;
			}

			@keyframes loading-bounce {
				0%,
				80%,
				100% {
					transform: scale(0);
					opacity: 0.5;
				}
				40% {
					transform: scale(1);
					opacity: 1;
				}
			}

			h1 {
				text-align: center;
				color: #333;
				margin-bottom: 10px;
				font-size: 28px;
			}

			.subtitle {
				text-align: center;
				color: #666;
				margin-bottom: 30px;
				font-size: 14px;
			}

			.status {
				background: #f5f5f5;
				border-left: 4px solid #667eea;
				padding: 12px 15px;
				margin-bottom: 20px;
				border-radius: 4px;
				font-size: 14px;
			}

			.status.connected {
				border-left-color: #4caf50;
				background: #e8f5e9;
			}

			.status.disconnected {
				border-left-color: #f44336;
				background: #ffebee;
			}

			.status.recording {
				border-left-color: #ff9800;
				background: #fff3e0;
			}

			.status.processing {
				border-left-color: #2196f3;
				background: #e3f2fd;
			}

			.status-text {
				font-weight: 600;
				color: #333;
			}

			.controls {
				display: flex;
				gap: 10px;
				margin-bottom: 30px;
				flex-wrap: wrap;
			}

			button {
				flex: 1;
				min-width: 60px;
				padding: 10px 12px;
				border: none;
				border-radius: 6px;
				font-size: 12px;
				font-weight: 600;
				cursor: pointer;
				transition: all 0.3s ease;
			}

			button:hover {
				transform: translateY(-2px);
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
			}

			button:disabled {
				opacity: 0.5;
				cursor: not-allowed;
				transform: none;
			}

			.btn-primary {
				background: #667eea;
				color: white;
			}

			.btn-primary:hover:not(:disabled) {
				background: #5568d3;
			}

			.btn-danger {
				background: #f44336;
				color: white;
			}

			.btn-danger:hover:not(:disabled) {
				background: #da190b;
			}

			.info-section {
				margin-bottom: 25px;
			}

			.section-title {
				font-size: 12px;
				font-weight: 700;
				text-transform: uppercase;
				color: #999;
				margin-bottom: 8px;
				letter-spacing: 0.5px;
			}

			.transcript-box,
			.response-box {
				background: #f9f9f9;
				border: 1px solid #e0e0e0;
				border-radius: 6px;
				padding: 12px;
				min-height: 60px;
				max-height: 120px;
				overflow-y: auto;
				font-size: 13px;
				line-height: 1.5;
				color: #333;
			}

			.empty-text {
				color: #999;
				font-style: italic;
			}

			.metrics {
				display: grid;
				grid-template-columns: 1fr 1fr;
				gap: 10px;
				margin-top: 15px;
			}

			.metric {
				background: #f5f5f5;
				padding: 10px;
				border-radius: 4px;
				text-align: center;
				font-size: 12px;
			}

			.metric-value {
				font-size: 16px;
				font-weight: 700;
				color: #667eea;
			}

			.metric-label {
				color: #999;
				margin-top: 3px;
			}

			.log-container {
				background: #1e1e1e;
				color: #d4d4d4;
				border-radius: 6px;
				padding: 12px;
				font-family: 'Courier New', monospace;
				font-size: 11px;
				max-height: 200px;
				overflow-y: auto;
				margin-top: 20px;
				display: none;
			}

			.log-container.dev {
				display: block;
			}

			.chat-input-container {
				border-top: 2px solid #e0e0e0;
				padding-top: 12px;
				position: relative;
			}

			.chat-input-wrapper {
				position: relative;
				display: flex;
				align-items: center;
			}

			.chat-input {
				flex: 1;
				padding: 10px 52px 10px 12px;
				border: 1px solid #e0e0e0;
				border-radius: 6px;
				font-size: 12px;
				font-family: inherit;
				outline: none;
				transition: border-color 0.2s;
				width: 100%;
			}

			.chat-input:focus {
				border-color: #667eea;
			}

			.chat-input::placeholder {
				color: #999;
			}

			.chat-send-icon {
				position: absolute;
				right: 2px;
				background: none;
				border: none;
				width: 30px;
				height: 40px;
				display: flex;
				align-items: center;
				justify-content: center;
				cursor: pointer;
				border-radius: 50%;
				transition: opacity 0.2s ease;
			}

			.chat-send-icon svg {
				width: 22px;
				height: 22px;
				fill: #667eea;
			}

			.chat-send-icon:disabled {
				opacity: 0.3;
				cursor: not-allowed;
			}
		</style>
	</head>

	<body>
		<div class="main-content">
			<div class="container">
				<h1>Virtual Partner Playground</h1>
				<p class="subtitle">Live Duplex Audio Streaming</p>

				<div class="status disconnected" id="status">
					<span class="status-text" id="statusText">Disconnected</span>
				</div>

				<div class="controls">
					<button class="btn-primary" id="recordBtn" onclick="startRecording()" disabled>Start</button>
					<button class="btn-danger" id="endBtn" onclick="endConversation()" disabled>Finish</button>
				</div>

				<div class="info-section">
					<div class="section-title">Your Transcription</div>
					<div class="transcript-box" id="transcript">
						<span class="empty-text">Waiting for audio...</span>
					</div>
				</div>

				<div class="info-section">
					<div class="section-title">AI Response</div>
					<div class="response-box" id="response">
						<span class="empty-text">Waiting for response...</span>
					</div>
				</div>

				<div class="info-section">
					<div class="section-title">Processing Metrics</div>
					<div class="metrics">
						<div class="metric">
							<div class="metric-value" id="bytesMetric">0</div>
							<div class="metric-label">Bytes Sent</div>
						</div>
						<div class="metric">
							<div class="metric-value" id="chunksMetric">0</div>
							<div class="metric-label">Chunks Sent</div>
						</div>
						<div class="metric">
							<div class="metric-value" id="timeMetric">0ms</div>
							<div class="metric-label">Processing Time</div>
						</div>
						<div class="metric">
							<div class="metric-value" id="recordTimeMetric">0s</div>
							<div class="metric-label">Recording Time</div>
						</div>
					</div>
				</div>

				<div class="log-container" id="logs"></div>
			</div>

			<div class="chat-sidebar">
				<div class="sidebar-title">Chat History</div>
				<div class="sidebar-messages" id="sidebarMessages">
					<p style="text-align: center; color: #999; font-size: 12px">Start recording to see messages...</p>
				</div>
				<div class="chat-input-container">
					<div class="chat-input-wrapper">
						<input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." disabled />
						<button class="chat-send-icon" id="sendIcon" disabled aria-label="Send message">
							<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
								<path d="M2 21l21-9L2 3v7l15 2-15 2v7z" />
							</svg>
						</button>
					</div>
				</div>
			</div>
		</div>

		<script>
			const IS_DEV = location.hostname === 'localhost' || location.hostname === '127.0.0.1'
			const SERVER_URL = IS_DEV ? 'ws://localhost:3000' : 'wss://virtual-partner-backend-production.up.railway.app'

			let socket = null
			let audioContext = null
			let processor = null
			let source = null
			let mediaStream = null
			let isRecording = false
			let recordingStartTime = null
			let recordingInterval = null
			let totalBytesSent = 0
			let chunksSent = 0
			let conversationId = null

			let audioOutputContext = null
			let currentSource = null

			let lastUserTranscriptTime = null
			let currentUserTranscript = ''
			let transcriptTimeout = null

			// Browser Fingerprinting for Anonymous Users
			function generateFingerprint() {
				const components = [
					navigator.userAgent,
					navigator.language,
					new Date().getTimezoneOffset(),
					screen.width + 'x' + screen.height,
					screen.colorDepth,
					navigator.platform,
					navigator.hardwareConcurrency || 'unknown',
					navigator.deviceMemory || 'unknown'
				]

				const fingerprint = components.join('|')

				let hash = 0

				for (let i = 0; i < fingerprint.length; i++) {
					const char = fingerprint.charCodeAt(i)

					hash = (hash << 5) - hash + char
					hash = hash | 0
				}

				const hashStr = Math.abs(hash).toString(36)

				return 'fp_' + hashStr
			}

			function getUserId() {
				let userId = localStorage.getItem('userId')

				if (!userId) {
					userId = generateFingerprint()
					localStorage.setItem('userId', userId)

					if (IS_DEV) log(`Generated new userId: ${userId}`)
				} else {
					if (IS_DEV) log(`Using existing userId: ${userId}`)
				}

				return userId
			}

			function log(message, type = 'message') {
				const logsContainer = document.getElementById('logs')
				const entry = document.createElement('div')
				entry.className = 'log-entry'

				const time = new Date().toLocaleTimeString('en-US', {
					hour12: false,
					hour: '2-digit',
					minute: '2-digit',
					second: '2-digit'
				})
				let html = `<span class="log-time">${time}</span> `

				if (type === 'error') html += `<span class="log-error">❌ ${message}</span>`
				else if (type === 'success') html += `<span class="log-success">✓ ${message}</span>`
				else html += `<span class="log-message">→ ${message}</span>`

				entry.innerHTML = html
				logsContainer.appendChild(entry)
				logsContainer.scrollTop = logsContainer.scrollHeight
			}

			function updateStatus(text, type) {
				const statusEl = document.getElementById('status')
				const statusText = document.getElementById('statusText')
				statusEl.className = `status ${type}`
				statusText.textContent = text
			}

			function updateMetrics() {
				document.getElementById('bytesMetric').textContent = (totalBytesSent / 1024).toFixed(2) + ' KB'
				document.getElementById('chunksMetric').textContent = chunksSent
				if (recordingStartTime) {
					const elapsed = ((Date.now() - recordingStartTime) / 1000).toFixed(1)
					document.getElementById('recordTimeMetric').textContent = elapsed + 's'
				}
			}

			function addChatMessage(text, role) {
				const container = document.getElementById('sidebarMessages')
				if (container.children[0]?.textContent.includes('Start recording')) {
					container.innerHTML = ''
				}

				const el = document.createElement('div')
				el.className = `sidebar-message ${role}`
				el.textContent = text
				container.appendChild(el)

				requestAnimationFrame(() => {
					container.scrollTop = container.scrollHeight
				})
			}

			function showLoadingMessage() {
				const container = document.getElementById('sidebarMessages')
				const el = document.createElement('div')

				removeLoadingMessage()

				el.className = 'sidebar-message loading'
				el.id = 'loading-message'
				el.innerHTML = '<div class="loading-dots"><span></span><span></span><span></span></div>'

				container.appendChild(el)

				requestAnimationFrame(() => {
					container.scrollTop = container.scrollHeight
				})
			}

			function removeLoadingMessage() {
				const loadingMsg = document.getElementById('loading-message')
				if (loadingMsg) {
					loadingMsg.remove()
				}
			}

			function updateCurrentUserMessage(text) {
				const container = document.getElementById('sidebarMessages')
				const lastMessage = container.lastElementChild

				if (lastMessage && lastMessage.classList.contains('user')) {
					lastMessage.textContent = text
				} else {
					addChatMessage(text, 'user')
				}

				requestAnimationFrame(() => {
					container.scrollTop = container.scrollHeight
				})
			}

			function initAudioContext() {
				if (!audioOutputContext || audioOutputContext.state === 'closed') {
					audioOutputContext = new (window.AudioContext || window.webkitAudioContext)({
						sampleRate: 24000,
						latencyHint: 'playback'
					})
				}
			}

			function playFullAIResponse(audioChunksBase64) {
				if (!audioChunksBase64 || audioChunksBase64.length === 0) {
					return
				}

				initAudioContext()

				let totalSamples = 0

				const int16Arrays = []

				for (const base64 of audioChunksBase64) {
					const binary = atob(base64)
					const bytes = new Uint8Array(binary.length)

					for (let i = 0; i < binary.length; i++) {
						bytes[i] = binary.charCodeAt(i)
					}

					const int16 = new Int16Array(bytes.buffer)

					int16Arrays.push(int16)

					totalSamples += int16.length
				}

				const buffer = audioOutputContext.createBuffer(1, totalSamples, 24000)
				const channelData = buffer.getChannelData(0)

				let offset = 0
				for (const arr of int16Arrays) {
					for (let i = 0; i < arr.length; i++) {
						channelData[offset++] = arr[i] / 32768.0
					}
				}

				if (currentSource) {
					try {
						currentSource.stop()
					} catch (_) {}
				}

				currentSource = audioOutputContext.createBufferSource()
				currentSource.buffer = buffer
				currentSource.connect(audioOutputContext.destination)
				currentSource.start()

				currentSource.onended = () => {
					currentSource = null
				}
			}

			function stopAudioCapture() {
				isRecording = false
				if (processor) processor.disconnect()
				if (source) source.disconnect()
				if (mediaStream) mediaStream.getTracks().forEach((track) => track.stop())
				if (audioContext && audioContext.state !== 'closed') audioContext.close()
				if (recordingInterval) clearInterval(recordingInterval)
				audioContext = processor = source = mediaStream = null
			}

			function resetRecordingState() {
				recordingStartTime = null
				totalBytesSent = 0
				chunksSent = 0
				updateMetrics()
			}

			function updateButtonStates(recording) {
				document.getElementById('recordBtn').disabled = recording
				document.getElementById('endBtn').disabled = !recording
				document.getElementById('chatInput').disabled = !recording
				updateSendIconState()
			}

			async function connect() {
				updateStatus('Connecting...', 'processing')
				if (IS_DEV) log('Attempting to connect to server...')

				socket = io(SERVER_URL + '/audio', {
					reconnection: true,
					reconnectionDelay: 1000,
					reconnectionDelayMax: 5000,
					reconnectionAttempts: 5
				})

				socket.on('connect', () => {
					updateStatus('Connected', 'connected')
					if (IS_DEV) log('Connected to server', 'success')
					document.getElementById('recordBtn').disabled = false
				})

				socket.on('disconnect', () => {
					updateStatus('Disconnected', 'disconnected')
					if (IS_DEV) log('Disconnected from server', 'error')
					document.getElementById('recordBtn').disabled = true
					document.getElementById('endBtn').disabled = true
					isRecording = false
				})

				socket.on('live-session-ready', () => {
					if (IS_DEV) log('Live API session ready', 'success')
				})

				socket.on('ai-response', (data) => {
					document.getElementById('response').textContent = data.text
					if (data.isFinal) {
						addChatMessage(data.text, 'assistant')
						// Chỉ ẩn loading khi AI response đã hoàn tất
						removeLoadingMessage()
					}
				})

				socket.on('ai-audio-complete', (data) => {
					playFullAIResponse(data.audioChunks)
				})

				socket.on('live-interrupted', () => {
					if (IS_DEV) log('AI interrupted')
					if (currentSource) {
						try {
							currentSource.stop()
						} catch (_) {}
						currentSource = null
					}
				})

				socket.on('stream-started', () => {
					if (IS_DEV) log('Stream started', 'success')
				})

				socket.on('user-transcript', (data) => {
					const text = data.text
					document.getElementById('transcript').textContent = text

					const now = Date.now()

					if (transcriptTimeout) {
						clearTimeout(transcriptTimeout)
					}

					if (!lastUserTranscriptTime || now - lastUserTranscriptTime > 1000) {
						currentUserTranscript = text
						addChatMessage(text, 'user')
						// Hiển thị loading ngay sau khi user nói xong
						showLoadingMessage()
					} else {
						currentUserTranscript = text
						updateCurrentUserMessage(text)
					}

					lastUserTranscriptTime = now

					transcriptTimeout = setTimeout(() => {
						lastUserTranscriptTime = null
						currentUserTranscript = ''
						// Hiển thị loading sau khi user dừng nói 1 giây
						showLoadingMessage()
					}, 1000)
				})

				socket.on('processing', (data) => {
					if (IS_DEV) log(`Processing: ${data.status}`)
					showLoadingMessage()
				})

				socket.on('error', (data) => {
					if (IS_DEV) log(`Error: ${data.message}`, 'error')
					updateStatus(`Error: ${data.code}`, 'disconnected')
				})
			}

			function sendTextMessage() {
				const input = document.getElementById('chatInput')
				const message = input.value.trim()

				if (!message) return

				if (IS_DEV) log(`Sending text message: ${message}`)

				addChatMessage(message, 'user')

				socket.emit('text-message', {
					text: message,
					conversationId,
					timestamp: Date.now()
				})

				input.value = ''
				updateSendIconState()
			}

			function updateSendIconState() {
				const input = document.getElementById('chatInput')
				const icon = document.getElementById('sendIcon')
				const hasText = input.value.trim().length > 0
				const isEnabled = !input.disabled

				icon.disabled = !(hasText && isEnabled)
			}

			document.addEventListener('DOMContentLoaded', () => {
				const chatInput = document.getElementById('chatInput')
				const sendIcon = document.getElementById('sendIcon')

				if (chatInput) {
					chatInput.addEventListener('input', updateSendIconState)
					chatInput.addEventListener('keypress', (e) => {
						if (e.key === 'Enter' && !e.shiftKey) {
							e.preventDefault()
							sendTextMessage()
						}
					})
				}

				if (sendIcon) {
					sendIcon.addEventListener('click', sendTextMessage)
				}
			})

			async function startRecording() {
				try {
					if (IS_DEV) log('Starting recording...')

					mediaStream = await navigator.mediaDevices.getUserMedia({
						audio: {
							channelCount: 1,
							sampleRate: 16000,
							echoCancellation: true,
							noiseSuppression: true
						}
					})

					audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 })
					source = audioContext.createMediaStreamSource(mediaStream)
					processor = audioContext.createScriptProcessor(4096, 1, 1)

					let chunkIndex = 0
					processor.onaudioprocess = (e) => {
						if (!isRecording) return

						const input = e.inputBuffer.getChannelData(0)
						const pcm = new Int16Array(input.length)
						for (let i = 0; i < input.length; i++) {
							const s = Math.max(-1, Math.min(1, input[i]))
							pcm[i] = s < 0 ? s * 0x8000 : s * 0x7fff
						}

						const buffer = new Uint8Array(pcm.buffer)
						const base64 = btoa(String.fromCharCode(...buffer))

						socket.emit('audio-chunk', { chunk: base64, chunkIndex: chunkIndex++ })
						totalBytesSent += buffer.length
						chunksSent++
					}

					source.connect(processor)
					processor.connect(audioContext.destination)

					conversationId = 'conv-' + Date.now()
					socket.emit('start-stream', {
						userId: getUserId(),
						sessionId: 'session-' + Date.now(),
						conversationId
					})

					recordingStartTime = Date.now()
					isRecording = true
					updateStatus('Recording...', 'recording')
					updateButtonStates(true)
					updateSendIconState()
					recordingInterval = setInterval(updateMetrics, 1000)
				} catch (err) {
					if (IS_DEV) log(`Recording error: ${err.message}`, 'error')
					updateStatus('Recording failed', 'disconnected')
				}
			}

			function endConversation() {
				if (IS_DEV) log('Ending conversation...')
				stopAudioCapture()
				socket.emit('end-conversation', { conversationId })
				updateStatus('Connected', 'connected')
				updateButtonStates(false)
				updateSendIconState()
				resetRecordingState()

				if (transcriptTimeout) {
					clearTimeout(transcriptTimeout)
					transcriptTimeout = null
				}
				lastUserTranscriptTime = null
				currentUserTranscript = ''
			}

			window.addEventListener('load', () => {
				if (IS_DEV) {
					document.getElementById('logs').classList.add('dev')
					log('Page loaded')
				}
				connect()
				setInterval(updateMetrics, 1000)
			})

			window.addEventListener('beforeunload', () => {
				if (socket) socket.disconnect()
			})
		</script>
	</body>
</html>
